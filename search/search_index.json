{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to LeetScrape","text":"<p>Introducing the LeetScrape - a powerful and efficient Python package designed to scrape problem statements and basic test cases from LeetCode.com. With this package, you can easily download and save LeetCode problems to your local machine, making it convenient for offline practice and studying. It is perfect for software engineers and students preparing for coding interviews. The package is lightweight, easy to use and can be integrated with other tools and IDEs. With the LeetScrape, you can boost your coding skills and improve your chances of landing your dream job.</p> <p>Use this package to get the list of Leetcode questions, their topic and company tags, difficulty, question body (including test cases, constraints, hints), and code stubs in any of the available programming languages.</p> <p>There is also a related Next.js web app to serve the scraped questions and your answers at leetcode-nextjs. See the demo.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#101-2024-01-04","title":"[1.0.1] - 2024-01-04","text":""},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Updated the pyproject.toml file to make <code>marko</code> a required dependency. It was previously an extra <code>file</code> dependency. I had included it as an extra so that users who simply want to get question information would not have to install <code>marko</code> as well. However, seeing as <code>leetscrape question &lt;qid&gt;</code> is a core feature of the package, I have decided to make <code>marko</code> a required dependency.</li> </ul>"},{"location":"CHANGELOG/#docs","title":"Docs","text":"<ul> <li>Added this changelog section to the docs.</li> <li>Fixed inactive badges in the Homepage.</li> </ul>"},{"location":"CHANGELOG/#readme","title":"README","text":"<ul> <li>Updated the README to call out the new Changelog page on the docs.</li> </ul>"},{"location":"extract_solution/","title":"ExtractSolution","text":"<p>Generate mdx files from solutions</p> <p>Once you have solved a question, you can generate an mdx file with the solution and the question statement using the <code>ExtractSolutions</code> class:</p> <p><pre><code>from leetscrape import ExtractSolutions\n\n# Get the question body\nsolutions = ExtractSolutions(filename=\"&lt;path-to-solution-file&gt;\").extract()\n</code></pre> This outputs a list of <code>Solution</code> objects with the following attributes:</p> <pre><code>solution.id # Solution ID\nsolution.code # Solution code\nsolution.docs # Docstrings associated with the solution\nsolution.problem_statement # Question body / problem statement\n</code></pre> <p>Alternatively, you can use the <code>to_mdx</code> method to generate the mdx file:</p> <pre><code>from leetscrape import ExtractSolutions\n\n# Get the question body\nExtractSolutions(filename=\"&lt;path-to-solution-file&gt;\").to_mdx(output_filename=\"&lt;path-to-output-file&gt;\")\n</code></pre> Source code in <code>src/leetscrape/extract_solution.py</code> <pre><code>class ExtractSolutions:\n    def __init__(self, filename: str):\n        self.filename = filename\n        with open(self.filename) as fd:\n            file_contents = fd.read()\n        self.module = ast.parse(file_contents)\n        self.solutions = None\n\n    def extract(self, top_class_name: str = \"Solution\") -&gt; list[Solution]:\n        \"\"\"\n        Extract solutions from a given python file.\n\n        Args:\n            filename (str): The path of the file to extract solutions from. This python script should have the solution method(s) in the class named in the top_class-name.\n            top_class_name (str, optional): The name of the class from which to extract the solutions from. Defaults to `Solution'.\n\n        Raises:\n            ValueError: When the filename does not follow the required convention of `q_{{LEETCODE_QID}}_ {{LEETCODE_TITLE}}.py`.\n            ValueError: When the provided python file does not have a class named Solution.\n\n        Returns:\n            list[Solution]: A list of solutions, each containing an id, code [and docs].\n        \"\"\"\n\n        class_definition = [\n            node\n            for node in self.module.body\n            if isinstance(node, ast.ClassDef) and node.name == top_class_name\n        ]\n        if not class_definition:\n            raise ValueError(\n                \"The provided python file should have a class named Solution.\"\n            )\n        method_definitions = [\n            node\n            for node in class_definition[0].body\n            if isinstance(node, ast.FunctionDef)\n        ]\n\n        self.solutions = [\n            Solution(\n                id=idx + 1,\n                code=self._extract_code(f),\n                docs=parse_method_docstring(ast.get_docstring(f, clean=True)),\n                problem_statement=ast.get_docstring(class_definition[0], clean=True),\n            )\n            for idx, f in enumerate(method_definitions)\n        ]\n\n        return self.solutions\n\n    def to_mdx(self, output_filename: str | None = None) -&gt; str:\n        if self.solutions is None:\n            self.extract()\n        front_matter = self._extract_front_matter()\n        # Add frontmatter\n        mdx = \"---\\n\"\n        for key, value in front_matter.items():\n            if isinstance(value, list):\n                mdx += f\"{key}: {', '.join(value)}\\n\"\n            else:\n                mdx += f\"{key}: {value}\\n\"\n        mdx += \"---\\n\\n\"\n        mdx += f\"{self.solutions[0].problem_statement}\\n\\n\"\n        mdx += \"## Solutions\\n\\n\"\n        for solution in self.solutions:\n            if len(self.solutions) &gt; 1:\n                mdx += f\"### Method {solution.id}\\n\\n\"\n            mdx += f\"```python\\nclass Solution:\\n{solution.code}```\\n\\n\"\n            if \"description\" in solution.docs:\n                mdx += f\"{solution.docs['description']}\\n\\n\"\n            if \"time\" in solution.docs and \"args\" in solution.docs[\"time\"]:\n                mdx += f\"**Time Complexity**: {solution.docs['time']['args'][1]}, {solution.docs['time']['description']}  \\n\"\n            if \"space\" in solution.docs and \"args\" in solution.docs[\"space\"]:\n                mdx += f\"**Space Complexity**: {solution.docs['space']['args'][1]}, {solution.docs['space']['description']}  \\n\"\n            mdx += \"\\n\"\n        if output_filename:\n            with open(output_filename, \"w\") as f:\n                f.write(mdx)\n        else:\n            return mdx\n\n    def _extract_code(\n        self,\n        node: ast.AsyncFunctionDef | ast.FunctionDef,\n    ) -&gt; str:\n        if node.lineno is not None and node.end_lineno is not None:\n            code_lines = node.lineno, node.end_lineno + 1\n        else:\n            raise ValueError(\"Node does not contain any code.\")\n        doc_lines = get_doc_string_lines(node)\n        with open(self.filename, \"r\") as f:\n            data = f.readlines()\n        lines_to_retain = []\n        for idx, line in enumerate(data):\n            if doc_lines is not None:\n                if ((idx + 1) in range(*code_lines)) and (\n                    (idx + 1) not in range(doc_lines[0], doc_lines[1] + 1)\n                ):\n                    lines_to_retain.append(line)\n            else:\n                if (idx + 1) in range(*code_lines):\n                    lines_to_retain.append(line)\n\n        return \"\".join(lines_to_retain)\n\n    def _extract_front_matter(\n        self, front_matter_name: str = \"front_matter\"\n    ) -&gt; dict[str, str | list[str]]:\n        \"\"\"\n        Extracts the front matter from the given AST module.\n\n        Args:\n            front_matter_name (str): The name of the variable containing the front matter. Defaults to \"front_matter\".\n\n        Returns:\n            dict[str, str | list[str]]: The extracted front matter as a dictionary.\n\n        Raises:\n            ValueError: If the front_matter is not a dictionary.\n        \"\"\"\n        front_matter = {}\n\n        for item in self.module.body:\n            if isinstance(item, ast.Assign) and any(\n                isinstance(target, ast.Name) and target.id == front_matter_name\n                for target in item.targets\n            ):\n                if not isinstance(item.value, ast.Dict):\n                    raise ValueError(\"front_matter must be a dict\")\n\n                for key, value in zip(item.value.keys, item.value.values):\n                    if isinstance(value, ast.Constant):\n                        front_matter[key.s] = value.s\n                    elif isinstance(value, ast.List):\n                        front_matter[key.s] = [el.s for el in value.elts]\n\n        return front_matter\n</code></pre>"},{"location":"extract_solution/#leetscrape.ExtractSolutions.extract","title":"<code>extract(top_class_name='Solution')</code>","text":"<p>Extract solutions from a given python file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path of the file to extract solutions from. This python script should have the solution method(s) in the class named in the top_class-name.</p> required <code>top_class_name</code> <code>str</code> <p>The name of the class from which to extract the solutions from. Defaults to `Solution\u2019.</p> <code>'Solution'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>When the filename does not follow the required convention of <code>q_{{LEETCODE_QID}}_ {{LEETCODE_TITLE}}.py</code>.</p> <code>ValueError</code> <p>When the provided python file does not have a class named Solution.</p> <p>Returns:</p> Type Description <code>list[Solution]</code> <p>list[Solution]: A list of solutions, each containing an id, code [and docs].</p> Source code in <code>src/leetscrape/extract_solution.py</code> <pre><code>def extract(self, top_class_name: str = \"Solution\") -&gt; list[Solution]:\n    \"\"\"\n    Extract solutions from a given python file.\n\n    Args:\n        filename (str): The path of the file to extract solutions from. This python script should have the solution method(s) in the class named in the top_class-name.\n        top_class_name (str, optional): The name of the class from which to extract the solutions from. Defaults to `Solution'.\n\n    Raises:\n        ValueError: When the filename does not follow the required convention of `q_{{LEETCODE_QID}}_ {{LEETCODE_TITLE}}.py`.\n        ValueError: When the provided python file does not have a class named Solution.\n\n    Returns:\n        list[Solution]: A list of solutions, each containing an id, code [and docs].\n    \"\"\"\n\n    class_definition = [\n        node\n        for node in self.module.body\n        if isinstance(node, ast.ClassDef) and node.name == top_class_name\n    ]\n    if not class_definition:\n        raise ValueError(\n            \"The provided python file should have a class named Solution.\"\n        )\n    method_definitions = [\n        node\n        for node in class_definition[0].body\n        if isinstance(node, ast.FunctionDef)\n    ]\n\n    self.solutions = [\n        Solution(\n            id=idx + 1,\n            code=self._extract_code(f),\n            docs=parse_method_docstring(ast.get_docstring(f, clean=True)),\n            problem_statement=ast.get_docstring(class_definition[0], clean=True),\n        )\n        for idx, f in enumerate(method_definitions)\n    ]\n\n    return self.solutions\n</code></pre>"},{"location":"generate_code_stubs/","title":"GenerateCodeStubs","text":"<p>Generate code stubs for a question</p> <p><pre><code>from leetscrape import GenerateCodeStub\n\n# Get the question body\nfcs = GenerateCodeStub(titleSlug=\"two-sum\")\nfcs.generate(directory=\"&lt;dir&gt;\")\n</code></pre> This generates the following files in the given directory: - <code>q_0001_twoSum.py</code> - Python file with the code stub for the given question with a function named <code>twoSum</code>. - <code>test_q_0001_twoSum.py</code> - Python file with the test cases for the given question.</p> <p>See examples for examples of the generated code stubs.</p> <p>Class to generate the code stub and pytest test file for a Leetcode question. The class may be instantiated by either a question\u2019s QID or its titleSlug. It creates a code stub with the question\u2019s statement, constrainsts, and basic test cases in the docstring.</p> <p>It also creates a pytest test file from the basic test cases in the question body.</p> <p>Parameters:</p> Name Type Description Default <code>titleSlug</code> <code>str</code> <p>The title slug of the question.</p> <code>None</code> <code>qid</code> <code>int</code> <p>The frontend question ID of the question.</p> <code>None</code> Source code in <code>src/leetscrape/generate_code_stub.py</code> <pre><code>class GenerateCodeStub:\n    \"\"\"Class to generate the code stub and pytest test file for a Leetcode question. The class may be instantiated by either a question's QID or its titleSlug. It creates a code stub with the question's statement, constrainsts, and basic test cases in the docstring.\n\n    It also creates a pytest test file from the basic test cases in the question body.\n\n    Args:\n        titleSlug (str, optional): The title slug of the question.\n        qid (int, optional): The frontend question ID of the question.\n    \"\"\"\n\n    def __init__(\n        self,\n        titleSlug: str | None = None,\n        qid: int | None = None,\n    ):\n        self.all_questions_stub_id = (\n            GetQuestion.fetch_all_questions_id_and_stub().reset_index().set_index(\"QID\")\n        )\n        self.titleSlug = titleSlug\n        self.qid = qid\n        if self.titleSlug is None:\n            if self.qid is None:\n                raise ValueError(\n                    \"At least one of titleSlug or qid needs to be specified.\"\n                )\n            elif self.qid in self.all_questions_stub_id.index:\n                self.titleSlug = self.all_questions_stub_id.loc[self.qid].titleSlug\n            else:\n                raise ValueError(\"There is no question with the passed qid\")\n        else:\n            if self.titleSlug in self.all_questions_stub_id.titleSlug.tolist():\n                if self.qid is not None:\n                    if (\n                        self.titleSlug\n                        != self.all_questions_stub_id.loc[self.qid].titleSlug\n                    ):\n                        raise ValueError(\n                            f\"Both titleSlug and qid were passed but they do not match.\\n\"\n                            + f\"{self.qid}: {self.all_questions_stub_id.loc[self.qid].titleSlug}\"\n                        )\n                else:\n                    self.qid = self.all_questions_stub_id[\n                        self.all_questions_stub_id[\"titleSlug\"] == self.titleSlug\n                    ].index[0]\n            else:\n                raise ValueError(\"There is no question with the passed titleSlug.\")\n        print(f\"Generating code stub for {self.qid}. {self.titleSlug}\")\n        self.filename = f\"q_{str(self.qid).zfill(4)}_{camel_case(self.titleSlug)}.py\"\n        questionInfoScraper = GetQuestion(titleSlug=self.titleSlug)\n        self.data: Question = questionInfoScraper.scrape()\n\n    def generate(self, testing=False, directory: str = \".\") -&gt; None:\n        \"\"\"Wrapper that creates the code stub and test files after formatting them through black.\n\n        Args:\n            testing (bool, optional): Whether we are in a testing environment. In testing environment, the files are not written to the disk. Defaults to False.\n            directory (str, optional): The directory where the files are to be written. Defaults to \".\".\n        \"\"\"\n        if directory.endswith(\"/\"):\n            directory = directory[:-1]\n        code_to_write = self._create_code_file()\n        if not self.data.isPaidOnly:\n            test_to_write = self._create_test_file(code_to_write)\n        if not testing:\n            with open(f\"{directory}/{self.filename}\", \"w\", encoding=\"utf-8\") as f:\n                f.write(format_str(code_to_write, mode=FileMode()))\n                print(f\"Code stub save to {self.filename}\")\n\n            if not self.data.isPaidOnly:\n                with open(\n                    f\"{directory}/test_{self.filename}\", \"w\", encoding=\"utf-8\"\n                ) as f:\n                    f.write(\n                        format_str(test_to_write, mode=FileMode())\n                    )  # ignore: unbounded\n                    print(f\"Test file written to test_{self.filename}.py\")\n\n    def _get_code_stub(self) -&gt; str:\n        \"\"\"Extracts the python code text from Leetcode's API response.\n\n        Returns:\n            str: The python code stub.\n        \"\"\"\n        return self.data.Code\n\n    def _get_problem_statement(self) -&gt; str:\n        \"\"\"Extracts the python problem statement from Leetcode's API response.\n\n        Returns:\n            str: Te problem statement in markdown format.\n        \"\"\"\n        # Because sup is non-standard markdown, we need to convert them to latex\n        problem_statement = re.sub(r\"&lt;sup&gt;(.*?)&lt;/sup&gt;\", r\"^{\\1}\", self.data.Body)\n        problem_statement_rst = md(problem_statement)\n        return (\n            problem_statement_rst.replace(\"**Input:**\", \"Input:\")\n            .replace(\"**Output:**\", \"Output:\")\n            .replace(\"**Explanation:**\", \"Explanation:\")\n        )\n\n    def _create_code_file(self) -&gt; str:\n        \"\"\"Prepares the text to be written in the python file.\n\n        Returns:\n            str: The text to be written in the python file.\n        \"\"\"\n        code_stub = self._get_code_stub()\n        problem_statement = self._get_problem_statement()\n        lines_to_write = []\n        front_matter = {\n            \"qid\": self.data.QID,\n            \"title\": self.data.title,\n            \"titleSlug\": self.data.titleSlug,\n            \"difficulty\": self.data.difficulty,\n            \"tags\": self.data.topics,\n        }\n        lines_to_write.append(f\"front_matter = {front_matter}\")\n        lines_to_write.append(\n            \"# ====================== DO NOT EDIT ABOVE THIS LINE ======================\"\n        )\n        for line in code_stub.split(\"\\n\"):\n            lines_to_write.append(line)\n            if line.startswith(\"class Solution\"):\n                lines_to_write.append(f'    \"\"\"{problem_statement}\"\"\"')\n            elif line.endswith(\":\") and not line.strip().startswith(\"#\"):\n                lines_to_write.append(\"        pass\")\n        lines_to_write.append(\n            \"    # If you have multiple solutions, add them all here as methods of the same class.\"\n        )\n        text_to_write = \"\\n\".join(lines_to_write).replace(\"\\n\\n\", \"\\n\")\n        return text_to_write\n\n    def _extract_codeblocks_in_problem_statement(\n        self, problem_statement: str\n    ) -&gt; list[str]:\n        \"\"\"Extract the code blocks from the given problem statement string. These codeblocks contain the basic test cases provided by Leetcode.\n\n        Args:\n            problem_statement (str): The problem statement with the code blocks\n\n        Returns:\n            list[str]: The list of code blocks. The length of list is equal to the number of basic test cases provided by Leetcode.\n        \"\"\"\n        mk = marko.Markdown()\n        markdown_text = mk.parse(problem_statement)\n        code_blocks = [\n            child.children[0].children\n            for child in markdown_text.children\n            if isinstance(child, marko.block.FencedCode)\n        ]\n        return code_blocks\n\n    def _get_parameters(self, code_blocks: list[str]) -&gt; tuple[str, str]:\n        \"\"\"Extract the inputs and outputs from each of the code block in the question body.\n\n        Args:\n            code_blocks (list[str]): The list of code block  in the question body.\n\n        Returns:\n            tuple[str, str]:\n                - str: The input string to be added to the test file.\n                - str: The output string to be added to the test file.\n        \"\"\"\n        parameters = []\n        for test in code_blocks:\n            if \"Input\" in test:\n                for line in test.split(\"\\n\"):\n                    if line.startswith(\"Input:\"):\n                        inp = line.split(\"Input:\")[1]\n                parameter_dict = parse_args(inp)  # type: ignore\n                parameter_dict[\"output\"] = re.search(\n                    \"Output: (.*)\\n\",\n                    test.replace(\"true\", \"True\").replace(\n                        \"false\", \"False\"\n                    ),  # Leetcode uses true and false for True and False, respectively.\n                )\n                if parameter_dict[\"output\"] is not None:\n                    parameter_dict[\"output\"] = parse_args(\n                        parameter_dict[\"output\"]\n                        .group(0)\n                        .replace(\"Output: \", \"Output= \")\n                        .replace(\"\\n\", \"\")\n                    )[\"Output\"]\n                parameters.append(parameter_dict)\n        output_string = \", \".join(list(parameters[0].keys()))\n        input_string = \", \".join(\n            f\"({test_case})\"\n            for test_case in [\n                \", \".join(\n                    [\n                        \"'{}'\".format(x) if isinstance(x, str) else str(x)\n                        for x in parameter.values()\n                    ]\n                )\n                for parameter in parameters\n            ]\n        )\n        return input_string, output_string\n\n    def _create_test_file(self, code_text: str) -&gt; str:\n        \"\"\"Generates the test file for the given question.\n\n        Args:\n            code_text (str): The text that contains the code stub. This is used to get the list of inputs arguments and the name of the method.\n\n        Returns:\n            str: The text containing the pytest test case.\n        \"\"\"\n        problem_statement = self._get_problem_statement()\n        problem_statement_code_blocks = self._extract_codeblocks_in_problem_statement(\n            problem_statement\n        )\n        input_string, output_string = self._get_parameters(\n            problem_statement_code_blocks\n        )\n        pytestParameterDecorator = (\n            f\"\"\"@pytest.mark.parametrize(\"{output_string}\", [{input_string}])\"\"\"\n        )\n        className = \"Solution\"\n\n        # //TODO: This should be used to find the classname instead of hard-coding it to \"Solution\"\n\n        # # Use the `parse` function to create an AST from the file's contents\n        # root = ast.parse(code_text)\n        # # Iterate through the top-level nodes in the AST\n        # for node in ast.walk(root):\n        #     # Check if the node is a ClassDef node\n        #     if isinstance(node, ast.ClassDef):\n        #         # Check if the class is not commented\n        #         if not node.name.startswith(\"#\"):\n        #             # Print the class name\n        #             print(node.name)  # type: ignore\n\n        methodsName = re.findall(\"\\n    def (.*):\", code_text)\n        for i, methodName in enumerate(methodsName):\n            a, b = methodName.split(\") -&gt; \")\n            methodsName[i] = f\"{a}, output: {b})\"\n        methods = [\n            f\"\"\"\n    def test_{methodName}:\n        sc = {className}()\n        assert sc.{methodName.split(\"(\")[0]}({output_string[:-7]}) == output\n        \"\"\"\n            for methodName in methodsName\n        ]\n        test_to_write = f\"\"\"import pytest\nfrom {self.filename.split(\".py\")[0]} import Solution\n\n{pytestParameterDecorator}\nclass Test{className}:\"\"\" + \"\".join(\n            methods\n        )\n\n        return test_to_write\n</code></pre>"},{"location":"generate_code_stubs/#leetscrape.GenerateCodeStub.generate","title":"<code>generate(testing=False, directory='.')</code>","text":"<p>Wrapper that creates the code stub and test files after formatting them through black.</p> <p>Parameters:</p> Name Type Description Default <code>testing</code> <code>bool</code> <p>Whether we are in a testing environment. In testing environment, the files are not written to the disk. Defaults to False.</p> <code>False</code> <code>directory</code> <code>str</code> <p>The directory where the files are to be written. Defaults to \u201c.\u201d.</p> <code>'.'</code> Source code in <code>src/leetscrape/generate_code_stub.py</code> <pre><code>def generate(self, testing=False, directory: str = \".\") -&gt; None:\n    \"\"\"Wrapper that creates the code stub and test files after formatting them through black.\n\n    Args:\n        testing (bool, optional): Whether we are in a testing environment. In testing environment, the files are not written to the disk. Defaults to False.\n        directory (str, optional): The directory where the files are to be written. Defaults to \".\".\n    \"\"\"\n    if directory.endswith(\"/\"):\n        directory = directory[:-1]\n    code_to_write = self._create_code_file()\n    if not self.data.isPaidOnly:\n        test_to_write = self._create_test_file(code_to_write)\n    if not testing:\n        with open(f\"{directory}/{self.filename}\", \"w\", encoding=\"utf-8\") as f:\n            f.write(format_str(code_to_write, mode=FileMode()))\n            print(f\"Code stub save to {self.filename}\")\n\n        if not self.data.isPaidOnly:\n            with open(\n                f\"{directory}/test_{self.filename}\", \"w\", encoding=\"utf-8\"\n            ) as f:\n                f.write(\n                    format_str(test_to_write, mode=FileMode())\n                )  # ignore: unbounded\n                print(f\"Test file written to test_{self.filename}.py\")\n</code></pre>"},{"location":"installation/","title":"Getting Started","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>Start by installing the package from pip or conda:</p> pipcondapoetry <pre><code>pip install leetscrape\n</code></pre> <pre><code>conda install leetscrape\n</code></pre> <pre><code>poetry add leetscrape\n</code></pre>"},{"location":"installation/#commands","title":"Commands","text":"<ul> <li><code>leetscrape list [\u2013out OUT]</code> - List all questions without generating code stub.</li> </ul> <pre><code>options:\n-h, --help         show a help message and exit\n--out OUT, -o OUT  Specify the output file name to store the list of questions.\n</code></pre> <ul> <li><code>leetscrape question [\u2013out OUT] qid [qid \u2026]</code> - Generate a code stub for the given question(s).</li> </ul> <pre><code>positional arguments:\nqid                Enter Leetcode question ID(s)\n\noptions:\n-h, --help         show this help message and exit\n--out OUT, -o OUT  Enter the path to the output directory\n</code></pre> <ul> <li><code>leetscrape solution [-h] [\u2013out OUT] input</code> - Generate mdx files from solutions.</li> </ul> <pre><code>positional arguments:\ninput              Enter the path to the solution directory with solution files or to a single\n                    solution file\n\noptions:\n-h, --help         show this help message and exit\n--out OUT, -o OUT  Enter the path to the output directory to save solutions mdx files\n</code></pre> <ul> <li><code>leetscrape ts [\u2013out OUT]</code> - Create the leetscrape-ts Next.js project to host the solutions.</li> </ul> <pre><code>options:\n-h, --help         show this help message and exit\n--out OUT, -o OUT  Enter the path to the output directory to save the project\n</code></pre>"},{"location":"leetscrape_ts/","title":"LeetScrape TS","text":"<p>You can use the leetscrape-ts Next.js template to serve your solutions on the web. See the demo. Visit the repo for more details. You can generate the project using the <code>leetscrape ts</code> command:</p> <p><pre><code>leetscrape ts --out ./ts\n</code></pre> This will bootstrap the project in the given directory. Follow the instructions in the README and create/modify the <code>.env.local</code> file. Then, run the following command to generate the mdx files:</p> <pre><code>leetscrape solution --out ./ts/src/content/solutions ./solutions\n</code></pre> <p>You can then run the project using the following command:</p> npmyarnpnpmbun <pre><code>cd ./ts\nnpm run dev\n</code></pre> <pre><code>cd ./ts\nyarn dev\n</code></pre> <pre><code>cd ./ts\npnpm dev\n</code></pre> <pre><code>cd ./ts\nbun dev\n</code></pre>"},{"location":"question/","title":"GetQuestion","text":"<p>Query individual question\u2019s information such as the body, test cases, constraints, hints, code stubs, and company tags using the <code>GetQuestion</code> class:</p> <pre><code>from leetscrape import GetQuestion\n\n# Get the question body\nquestion = GetQuestion(titleSlug=\"two-sum\").scrape()\n</code></pre> <p>This returns a <code>Question</code> object with the following attributes:</p> <pre><code>question.QID # Question ID\nquestion.title # Question title\nquestion.titleSlug # Question title slug\nquestion.difficulty # Question difficulty\nquestion.Hints # Question hints\nquestion.Companies # Question companies\nquestion.topics # Question topic tags\nquestion.SimilarQuestions # Similar questions ids\nquestion.Code # Code stubs\nquestion.Body # Question body / problem statement\nquestion.isPaidOnly # Whether the question is only available to premium users of Leetcode\n</code></pre> <p>A class to acquire the statement, constraints, hints, basic test cases, related questions, and code stubs of the given question.</p> <p>Parameters:</p> Name Type Description Default <code>titleSlug</code> <code>str</code> <p>The title slug of the question.</p> required Source code in <code>src/leetscrape/question.py</code> <pre><code>class GetQuestion:\n    \"\"\"\n    A class to acquire the statement, constraints, hints, basic test cases, related questions, and code stubs of the given question.\n\n    Args:\n        titleSlug (str): The title slug of the question.\n    \"\"\"\n\n    def __init__(self, titleSlug: str):\n        self.titleSlug = titleSlug\n        self.questions_info = self.fetch_all_questions_id_and_stub()\n\n    @staticmethod\n    def fetch_all_questions_id_and_stub():\n        req = requests.get(\"https://leetcode.com/api/problems/all/\").json()\n        question_data = pd.json_normalize(req[\"stat_status_pairs\"]).rename(\n            columns={\n                \"stat.frontend_question_id\": \"QID\",\n                \"stat.question__title_slug\": \"titleSlug\",\n            }\n        )[[\"QID\", \"titleSlug\"]]\n\n        return question_data.sort_values(\"QID\").set_index(\"titleSlug\")\n\n    def scrape(self) -&gt; Question:\n        \"\"\"This method calls the Leetcode graphql api to query for the hints, companyTags (currently returning null as this is a premium feature), code snippets, and content of the question.\n\n        Raises:\n            ValueError: When the connection to Leetcode's graphql api is not established.\n\n        Returns:\n            QuestionInfo: Contains the QID, titleSlug, Hints, Companies, Similar Questions, Code stubs, and the body of the question.\n        \"\"\"\n        data = {\n            \"query\": \"\"\"query questionHints($titleSlug: String!) {\n                question(titleSlug: $titleSlug) {\n                    questionFrontendId\n                    title\n                    hints\n                    difficulty\n                    companyTags {\n                        name\n                        slug\n                        imgUrl\n                    }\n                    topicTags {\n                        name\n                    }\n                    similarQuestions\n                    codeSnippets {\n                        lang\n                        langSlug\n                        code\n                    }\n                    content\n                    isPaidOnly\n                }\n            }\n        \"\"\",\n            \"variables\": {\"titleSlug\": self.titleSlug},\n        }\n        response = requests.post(BASE_URL, json=data)\n        if response.status_code == 404:\n            raise ValueError(\"Leetcode's graphql API can't be found.\")\n        while response.status_code == 429 | 400:\n            time.sleep(10)\n            response = requests.post(BASE_URL, json=data)\n            if response.status_code == 404:\n                raise ValueError(\"Leetcode's graphql API can't be found.\")\n        response = response.json()\n        return Question(\n            QID=response[\"data\"][\"question\"][\"questionFrontendId\"],\n            title=response[\"data\"][\"question\"][\"title\"],\n            titleSlug=self.titleSlug,\n            difficulty=response[\"data\"][\"question\"][\"difficulty\"],\n            Hints=response[\"data\"][\"question\"][\"hints\"],\n            Companies=response[\"data\"][\"question\"][\"companyTags\"],\n            topics=[\n                topic[\"name\"] for topic in response[\"data\"][\"question\"][\"topicTags\"]\n            ],\n            isPaidOnly=response[\"data\"][\"question\"][\"isPaidOnly\"],\n            Body=self._get_question_body(response),\n            Code=self._get_code_snippet(response),\n            SimilarQuestions=self._get_similar_questions(response),\n        )\n\n    def _get_question_body(self, response) -&gt; str:  # type: ignore\n        if not response[\"data\"][\"question\"][\"isPaidOnly\"]:\n            return response[\"data\"][\"question\"][\"content\"]\n        else:\n            warnings.warn(\"This questions is only for paid Leetcode subscribers.\")\n            return \"This questions is only for paid Leetcode subscribers.\"\n\n    # Similar questions\n    def _get_similar_questions(self, response) -&gt; list[int]:\n        \"\"\"A helper method to extract the list of similar questions of the\n        given question.\n\n        Returns:\n            list[int]: The list of QIDs of the questions similar to the given question.\n        \"\"\"\n        similar_questions = []\n        for qs in json.loads(response[\"data\"][\"question\"][\"similarQuestions\"]):\n            similar_questions.append(self.questions_info.loc[qs[\"titleSlug\"]].QID)\n        return similar_questions\n\n    # Code Snippet\n    def _get_code_snippet(self, response) -&gt; str:  # type: ignore\n        \"\"\"A helper method to extract the code snippets from the query response.\n        Currently, this method returns the Python3 code snippet if available,\n        else it returns a barebones Python3 code snippet with the class name and\n        method named after the titleSlug.\n\n        Returns:\n            str: Python3 code snippet\n        \"\"\"\n        if not response[\"data\"][\"question\"][\"isPaidOnly\"]:\n            python_code_snippet = [\n                code_snippet\n                for code_snippet in response[\"data\"][\"question\"][\"codeSnippets\"]\n                if code_snippet[\"langSlug\"] == \"python3\"\n            ]\n            if len(python_code_snippet) &gt; 0:\n                return python_code_snippet[0][\"code\"]\n            else:\n                return NO_PYTHON_STUB.format(camel_case(self.titleSlug))\n        else:\n            warnings.warn(\"This questions is only for paid Leetcode subscribers.\")\n            return PREMIUM_CUSTOMER_PYTHON_STUB.format(camel_case(self.titleSlug))\n</code></pre>"},{"location":"question/#leetscrape.GetQuestion.scrape","title":"<code>scrape()</code>","text":"<p>This method calls the Leetcode graphql api to query for the hints, companyTags (currently returning null as this is a premium feature), code snippets, and content of the question.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When the connection to Leetcode\u2019s graphql api is not established.</p> <p>Returns:</p> Name Type Description <code>QuestionInfo</code> <code>Question</code> <p>Contains the QID, titleSlug, Hints, Companies, Similar Questions, Code stubs, and the body of the question.</p> Source code in <code>src/leetscrape/question.py</code> <pre><code>def scrape(self) -&gt; Question:\n    \"\"\"This method calls the Leetcode graphql api to query for the hints, companyTags (currently returning null as this is a premium feature), code snippets, and content of the question.\n\n    Raises:\n        ValueError: When the connection to Leetcode's graphql api is not established.\n\n    Returns:\n        QuestionInfo: Contains the QID, titleSlug, Hints, Companies, Similar Questions, Code stubs, and the body of the question.\n    \"\"\"\n    data = {\n        \"query\": \"\"\"query questionHints($titleSlug: String!) {\n            question(titleSlug: $titleSlug) {\n                questionFrontendId\n                title\n                hints\n                difficulty\n                companyTags {\n                    name\n                    slug\n                    imgUrl\n                }\n                topicTags {\n                    name\n                }\n                similarQuestions\n                codeSnippets {\n                    lang\n                    langSlug\n                    code\n                }\n                content\n                isPaidOnly\n            }\n        }\n    \"\"\",\n        \"variables\": {\"titleSlug\": self.titleSlug},\n    }\n    response = requests.post(BASE_URL, json=data)\n    if response.status_code == 404:\n        raise ValueError(\"Leetcode's graphql API can't be found.\")\n    while response.status_code == 429 | 400:\n        time.sleep(10)\n        response = requests.post(BASE_URL, json=data)\n        if response.status_code == 404:\n            raise ValueError(\"Leetcode's graphql API can't be found.\")\n    response = response.json()\n    return Question(\n        QID=response[\"data\"][\"question\"][\"questionFrontendId\"],\n        title=response[\"data\"][\"question\"][\"title\"],\n        titleSlug=self.titleSlug,\n        difficulty=response[\"data\"][\"question\"][\"difficulty\"],\n        Hints=response[\"data\"][\"question\"][\"hints\"],\n        Companies=response[\"data\"][\"question\"][\"companyTags\"],\n        topics=[\n            topic[\"name\"] for topic in response[\"data\"][\"question\"][\"topicTags\"]\n        ],\n        isPaidOnly=response[\"data\"][\"question\"][\"isPaidOnly\"],\n        Body=self._get_question_body(response),\n        Code=self._get_code_snippet(response),\n        SimilarQuestions=self._get_similar_questions(response),\n    )\n</code></pre>"},{"location":"questions_list/","title":"GetQuestionsList","text":"<p>Get the list of problems and their information</p> <pre><code>from leetscrape import GetQuestionsList\n\nls = GetQuestionsList()\nls.scrape() # Scrape the list of questions\nls.questions.head() # Get the list of questions\n</code></pre> QID title titleSlug difficulty acceptanceRate paidOnly topicTags categorySlug 0 1 Two Sum two-sum Easy 51.4225 False array,hash-table algorithms 1 2 Add Two Numbers add-two-numbers Medium 41.9051 False linked-list,math,recursion algorithms 2 3 Longest Substring Without Repeating Characters longest-substring-without-repeating-characters Medium 34.3169 False hash-table,string,sliding-window algorithms 3 4 Median of Two Sorted Arrays median-of-two-sorted-arrays Hard 38.8566 False array,binary-search,divide-and-conquer algorithms 4 5 Longest Palindromic Substring longest-palindromic-substring Medium 33.4383 False string,dynamic-programming algorithms <p>You can export the associated tables to a directory using the <code>to_csv</code> method:</p> <p><pre><code>ls.to_csv(directory=\"&lt;dir&gt;\")\n</code></pre> This generates 6 <code>.csv</code> files in the current directory: - <code>questions.csv</code> - List of questions with their title, difficulty, acceptance rate, paid status, topic tags, and category. - <code>companies.csv</code> - List of companies with their name, slug, and the questions count. - <code>topicsTags.csv</code> - List of topic tags with their name and slug. - <code>categories.csv</code> - List of categories with their name and slug. - <code>questionCategory.csv</code> - An edgelist of questions and their categories. - <code>questionTopics.csv</code> - An edgelist of questions and their topic tags.  </p> <p>A class to scrape the list of questions, their topic tags, and company tags.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of questions to query for from Leetcode\u2019s graphql API. Defaults to 10,000.</p> <code>10000</code> Source code in <code>src/leetscrape/questions_list.py</code> <pre><code>class GetQuestionsList:\n    \"\"\"A class to scrape the list of questions, their topic tags, and company tags.\n\n    Args:\n        limit (int, optional): The maximum number of questions to query for from Leetcode's graphql API. Defaults to 10,000.\n    \"\"\"\n\n    def __init__(self, limit: int = 10_000):\n        self.limit = limit\n\n    def scrape(self):\n        \"\"\"Scrapes LeetCode data including company tags, questions, question topics,\n        and categories.\n        \"\"\"\n        self._scrape_companies()\n        self._scrape_questions_list()\n        self._extract_question_topics()\n        self._get_categories_and_topicTags_lists()\n        self._scrape_question_category()\n        self._add_category_to_questions_list()\n\n    def to_csv(self, directory: str) -&gt; None:\n        \"\"\"A method to export the scraped data into csv files in preparation for\n        injection into a database.\n\n        Args:\n            directory (str): The directory path to export the scraped data into.\n        \"\"\"\n        self.companies.to_csv(directory + \"companies.csv\", index=False)\n        self.questions[\"QID\"] = self.questions[\"QID\"].astype(int)\n        self.questions.to_csv(directory + \"questions.csv\", index=False)\n        self.questionTopics.to_csv(\n            directory + \"questionTopics.csv\", index=True, index_label=\"id\"\n        )\n        self.categories.to_csv(directory + \"categories.csv\", index=False)\n        self.topicTags.to_csv(directory + \"topicTags.csv\", index=False)\n        self.questionCategory.to_csv(\n            directory + \"questionCategory.csv\", index=True, index_label=\"id\"\n        )\n\n    def _scrape_companies(self):\n        \"\"\"Scrape the company tags of each question. This always returns an empty\n        dataframe as this is a paid only feature.\"\"\"\n        print(\"Scraping companies ... \", end=\"\")\n        data = {\n            \"query\": \"\"\"query questionCompanyTags {\n                    companyTags {\n                        name\n                        slug\n                        questionCount\n                    }\n                }\n            \"\"\",\n            \"variables\": {},\n        }\n        r = requests.post(\"https://leetcode.com/graphql\", json=data).json()\n        self.companies = pd.json_normalize(r[\"data\"][\"companyTags\"])\n        print(\"Done\")\n\n    def _scrape_questions_list(self):\n        \"\"\"\n        Scrapes the list of questions from leetcode.com and store them in the 'questions' dataframe. The columns include the question QID, acceptance rate, difficulty, title, titleSlug, and topic tags. It also has a column indicating whether the question is available only to Leetcode's paying customers.\n        \"\"\"\n        print(\"Scraping questions list ... \", end=\"\")\n        data = {\n            \"query\": \"\"\"query problemsetQuestionList($categorySlug: String, $limit: Int, $skip: Int, $filters: QuestionListFilterInput) {\n                    problemsetQuestionList: questionList(\n                        categorySlug: $categorySlug\n                        limit: $limit\n                        skip: $skip\n                        filters: $filters\n                    ) {\n                        total: totalNum\n                        questions: data {\n                            acceptanceRate: acRate\n                            difficulty\n                            QID: questionFrontendId\n                            paidOnly: isPaidOnly\n                            title\n                            titleSlug\n                            topicTags {\n                                slug\n                            }\n                        }\n                    }\n                }\n            \"\"\",\n            \"variables\": {\n                \"categorySlug\": \"\",\n                \"skip\": 0,\n                \"limit\": self.limit,\n                \"filters\": {},\n            },\n        }\n\n        r = requests.post(\"https://leetcode.com/graphql\", json=data).json()\n        self.questions = pd.json_normalize(\n            r[\"data\"][\"problemsetQuestionList\"][\"questions\"]\n        )[\n            [\n                \"QID\",\n                \"title\",\n                \"titleSlug\",\n                \"difficulty\",\n                \"acceptanceRate\",\n                \"paidOnly\",\n                \"topicTags\",\n            ]\n        ]\n        self.questions[\"topicTags\"] = self.questions[\"topicTags\"].apply(\n            lambda w: [tag[\"slug\"] for tag in w]\n        )\n        print(\"Done\")\n\n    def _extract_question_topics(self):\n        \"\"\"Create a table with the edge list of questions and topic tags.\"\"\"\n        print(\"Extracting question topics ... \", end=\"\")\n        self.questionTopics = (\n            self.questions[[\"QID\", \"topicTags\"]]\n            .rename(columns={\"topicTags\": \"tagSlug\"})\n            .explode(\"tagSlug\", ignore_index=True)\n        ).dropna()\n        print(\"Done\")\n\n    def _get_categories_and_topicTags_lists(self):\n        \"\"\"Get the categories and topic tags of LeetCode problems and store them in the\n        'categories' and 'topicTags' attribute respectively.\"\"\"\n        print(\"Getting Categories ... \", end=\"\")\n        # List of problem categories\n        self.categories = pd.DataFrame.from_records(CATEGORIES)\n        print(\"Done\")\n        # List of problem topic tags\n        print(\"Scraping Topic Tags ... \", end=\"\")\n        self.topicTags = pd.DataFrame.from_records(TOPIC_TAGS)\n        print(\"Done\")\n\n    def _scrape_question_category(self):\n        \"\"\"Scrape the category of each question and store it in the 'questionCategory' dataframe.\"\"\"\n        print(\"Extracting question category ... \", end=\"\")\n        categories_data = []\n        for category in self.categories[\"slug\"].values:\n            data = {\n                \"query\": \"\"\"query problemsetQuestionList($categorySlug: String, $limit: Int, $skip: Int, $filters: QuestionListFilterInput) {\n                        problemsetQuestionList: questionList(\n                            categorySlug: $categorySlug\n                            limit: $limit\n                            skip: $skip\n                            filters: $filters\n                        ) {\n                            questions: data {\n                                QID: questionFrontendId\n                            }\n                        }\n                    }\n                \"\"\",\n                \"variables\": {\n                    \"categorySlug\": category,\n                    \"skip\": 0,\n                    \"limit\": self.limit,\n                    \"filters\": {},\n                },\n            }\n\n            r = requests.post(\"https://leetcode.com/graphql\", json=data).json()\n            categories = pd.json_normalize(\n                r[\"data\"][\"problemsetQuestionList\"][\"questions\"]\n            )\n            categories[\"categorySlug\"] = category\n            categories_data.append(categories)\n        self.questionCategory = pd.concat(categories_data, axis=0, ignore_index=True)\n        print(\"Done\")\n\n    def _add_category_to_questions_list(self):\n        \"\"\"Adds the `topicTags` column containing the comma-separated string of\n        the list of topic tags relevant to the given questions and the `category`\n        column that includes the category relevant to the given question\"\"\"\n        self.questions[\"topicTags\"] = self.questions[\"topicTags\"].apply(\n            lambda w: \",\".join(w)\n        )\n        self.questions = self.questions.join(\n            self.questionCategory.set_index(\"QID\"), on=\"QID\"\n        )\n</code></pre>"},{"location":"questions_list/#leetscrape.GetQuestionsList.scrape","title":"<code>scrape()</code>","text":"<p>Scrapes LeetCode data including company tags, questions, question topics, and categories.</p> Source code in <code>src/leetscrape/questions_list.py</code> <pre><code>def scrape(self):\n    \"\"\"Scrapes LeetCode data including company tags, questions, question topics,\n    and categories.\n    \"\"\"\n    self._scrape_companies()\n    self._scrape_questions_list()\n    self._extract_question_topics()\n    self._get_categories_and_topicTags_lists()\n    self._scrape_question_category()\n    self._add_category_to_questions_list()\n</code></pre>"},{"location":"questions_list/#leetscrape.GetQuestionsList.to_csv","title":"<code>to_csv(directory)</code>","text":"<p>A method to export the scraped data into csv files in preparation for injection into a database.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>The directory path to export the scraped data into.</p> required Source code in <code>src/leetscrape/questions_list.py</code> <pre><code>def to_csv(self, directory: str) -&gt; None:\n    \"\"\"A method to export the scraped data into csv files in preparation for\n    injection into a database.\n\n    Args:\n        directory (str): The directory path to export the scraped data into.\n    \"\"\"\n    self.companies.to_csv(directory + \"companies.csv\", index=False)\n    self.questions[\"QID\"] = self.questions[\"QID\"].astype(int)\n    self.questions.to_csv(directory + \"questions.csv\", index=False)\n    self.questionTopics.to_csv(\n        directory + \"questionTopics.csv\", index=True, index_label=\"id\"\n    )\n    self.categories.to_csv(directory + \"categories.csv\", index=False)\n    self.topicTags.to_csv(directory + \"topicTags.csv\", index=False)\n    self.questionCategory.to_csv(\n        directory + \"questionCategory.csv\", index=True, index_label=\"id\"\n    )\n</code></pre>"}]}